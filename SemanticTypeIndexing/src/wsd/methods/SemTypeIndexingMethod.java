//=== File Prolog ==========================================================
//    This code was developed for National Library of Medicine, Cognitive
//    Science Branch
//
//--- Notes ----------------------------------------------------------------
//
//
//--- Development History --------------------------------------------------
//    Date        Author             Reference
//    ----        ------             ---------
//    06/27/06    Willie Rogers    Initial Version
//
//--- Warning --------------------------------------------------------------
//    This software is property of the National Library of Medicine.
//    Unauthorized use or duplication of this software is
//    strictly prohibited.  Authorized users are subject to the following
//    restrictions:
//    *   Neither the author, their corporation, nor NLM is responsible for
//        any consequence of the use of this software.
//    *   The origin of this software must not be misrepresented either by
//        explicit claim or omission.
//    *   Altered versions of this software must be plainly marked as such.
//    *   This notice may not be removed or altered.
//
//=== End File Prolog ======================================================
package wsd.methods;

import java.util.*;
import java.io.*;

import org.apache.log4j.Logger;
import org.apache.log4j.Level;
import org.apache.log4j.BasicConfigurator;

import wsd.util.IntArrayIndex;
import wsd.util.IntArrayBinSearchPool;
import gov.nih.nlm.nls.utils.StringUtils;
import java.text.DecimalFormat;

/**
 * Implementation of Semantic Type Indexing in Java.  Based on Susanne
 * Humphrey's semantic-type4 function originally implemented in Lisp.
 * Sussanne's tables have been tranferred to inverted files
 * implemented using binary search table partitioned by term length
 * generated by the module java class wsd.util.IntArrayIndex.
 *
 * <P>This code was developed for National Library of Medicine, Cognitive
 * Science Branch.
 *
 * <p>$Id: SemTypeIndexingMethod.java,v 1.12 2006/09/25 18:38:25 wrogers Exp $</p>
 *
 * <p>Description: Word Sense Disambiguation</p>
 *
 * @version  27jun2006
 * @author   Willie Rogers
 */
public class SemTypeIndexingMethod
{

  /** which database to use this should be added to server configuration file */
  /** size of semantic type (ST) feature vectors */
  public static final int STVECTORSIZE = 129;
  /** table of semantic type names in order of their occurance within ST feature vectors */
  public static final String stAbbrev[] = {
    "aapp","acab","acty","aggp","alga","amph","anab","anim","anst","antb",
    "arch","bacs","bact","bdsu","bdsy","bhvr","biof","bird","blor","bmod",
    "bodm","bpoc","bsoj","carb","celc","celf","cell","cgab","chem","chvf",
    "chvs","clas","clna","clnd","cnce","comd","diap","dora","dsyn","edac",
    "eehu","eico","elii","emod","emst","enzy","evnt","famg","ffas","fish",
    "fndg","fngs","food","ftcn","genf","geoa","gngm","gora","grpa","grup",
    "hcpp","hcro","hlca","hops","horm","humn","idcn","imft","inbe","inch",
    "inpo","inpr","invt","irda","lang","lbpr","lbtr","lipd","mamm","mbrt",
    "mcha","medd","menp","mnob","mobd","moft","neop","nnon","npop","nsba",
    "nusq","ocac","ocdi","opco","orch","orga","orgf","orgm","orgt","ortf",
    "patf","phob","phpr","phsf","phsu","plnt","podg","popg","prog","qlco",
    "qnco","rcpt","rept","resa","resd","rich","rnlw","sbst","shro","socb",
    "sosy","spco","strd","tisu","tmco","topp","virs","vita","vtbt"
  };
  /** string containing known punctuation */
  public static final String PUNCTUATION = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  /** string containing known whitespace */
  public static final String WHITESPACE = " \t\n\r\f";
  /** Logger for this class */
  private static Logger logger = Logger.getLogger(SemTypeIndexingMethod.class);
  /** set format for scores in test method */
  private static DecimalFormat scoreFormat = new DecimalFormat("0.0000");
  /** Filename for Berkeley DB Term/STI score file used by Semantic Type Indexing Method */

  /** list of allowed words */
  public static Set restrictwords;
  /** list of not allowed words */
  public static Set stopwords;

  /** configuration properties for method, system property: CONFIG_FILE */
  public static String CONFIG_FILE =
    System.getProperty("CONFIG_FILE", "stimethod.cfg");

  /** configuration properties */
  public static Properties properties = new Properties(); // to be filled-in by static initializer method

  static {
    logger.setLevel(Level.INFO);
    BasicConfigurator.configure();
    try {
      // System.out.println("loading properties file " + CONFIG_FILE);
      InputStream in = new FileInputStream(CONFIG_FILE);
      properties.load(in);
    } catch (FileNotFoundException fnfe) {
      System.err.print(fnfe.getMessage());
      throw new RuntimeException("method settings cannot be loaded.");
    } catch (IOException ioe) {
      System.err.print(ioe.getMessage());
      throw new RuntimeException("method settings cannot be loaded.");
    }     
  }

  /** path of Semantic Type Index, config file property: DISAMB_SERVER_STI_INDEXPATH */
  public static String fSemanticTypeIndexingIndexFilePath =
    properties.getProperty("DISAMB_SERVER_STI_INDEXPATH", "wstv-dc"); // STI-IF Method
  /** file containing list of allowed words, config file property: DISAMB_SERVER_STI_RESTRICTWORDSFILE */
  public static String fSemanticTypeIndexingIndexRestrictWordsFile =
    properties.getProperty("DISAMB_SERVER_STI_RESTRICTWORDSFILE", "restrictwords.txt");
  /** file containing list of not allowed words config file property: DISAMB_SERVER_STI_STOPWORDSFILE */
  public static String fSemanticTypeIndexingIndexStopWordsFile =
    properties.getProperty("DISAMB_SERVER_STI_STOPWORDSFILE", "stopwords.txt");

  static {
    restrictwords = loadWordSet(fSemanticTypeIndexingIndexRestrictWordsFile);
    stopwords = loadWordSet(fSemanticTypeIndexingIndexStopWordsFile);
    logger.debug("SemTypeIndexingMethod:class init: STI index initialized");
  }

  /** Disk-based pool of partitioned binary search files of ascii-keyed integer arrays */
  public IntArrayBinSearchPool fIndexSemTypeIndexingTable = null;

  public SemTypeIndexingMethod() 
  {
    try {
      IntArrayIndex iai = IntArrayIndex.getInstance(fSemanticTypeIndexingIndexFilePath);
      fIndexSemTypeIndexingTable = iai.getIntArrayBinSearchPool();
    } catch (IOException e) {
      logger.error(e.getMessage(), e);
    } catch (ClassNotFoundException e) {
      logger.error(e.getMessage(), e);
    } 
  }

  public static Set loadWordSet(String filename)
  {
    Set wordSet = new HashSet();
    try {
      StreamTokenizer st = 
        new StreamTokenizer(new BufferedReader(new FileReader(filename)));
      while(st.nextToken() != StreamTokenizer.TT_EOF) {
        if (st.ttype == StreamTokenizer.TT_WORD)
          wordSet.add(st.sval);
      }
    } catch (FileNotFoundException e) {
      logger.error("loadWordSet:" + e.getMessage(), e);
    } catch (IOException e) {
      logger.error("loadWordSet:" + e.getMessage(), e);
    }
    return wordSet;
  }

  public static boolean isRestrictWord(String term)
  {
    return restrictwords.contains(term.toUpperCase());
  }

  public static boolean notStopWord(String term)
  {
    return (! stopwords.contains(term.toUpperCase()));
  }

  /** Susanne's modification removing QLCO and FNDG from pair of STs for a
      concept.*/
  public static List removeGeneralSemtypesFromPairs(List semanticTypes)
  {
    if (semanticTypes.size() <= 1) 
      return semanticTypes;
    List specificSemanticTypes = new ArrayList();
    for (int i=0; i < semanticTypes.size(); i++)
      {
        String semTypeAbbrev = (String)semanticTypes.get(i);
        if ((semTypeAbbrev != "qlco") && (semTypeAbbrev != "fndg"))
          specificSemanticTypes.add(semTypeAbbrev);
      }
    if (specificSemanticTypes.size() == 0)
      return semanticTypes;
    else
      return specificSemanticTypes;
  }

  /**
   * Close the Semantic Type Indexing Table.
   */
  public void finalize()
  {
    try
      {
        fIndexSemTypeIndexingTable.close();
      }
    catch (IOException e)
      {
        logger.error(e.getMessage(), e);
      }
  }

  // debug
  public void logStiResult(int[] resultVector, int topN)
  {
    SortedMap resultMap = mapStiResult(resultVector);
    int i = 0;
    Iterator mapIterator = resultMap.keySet().iterator();
    while (mapIterator.hasNext() && i < topN) {
      Double score = (Double)mapIterator.next();
      logger.debug( score + " " + resultMap.get(score));
      i++;
    }
  }

  public void logStiResult(int[] resultVector, List semtypes)
  {
    StringBuffer sb = new StringBuffer();
    sb.append("ranks: ");
    SortedMap resultMap = mapStiResultBySemType(resultVector);
    int i = 0;
    ListIterator semtypeIterator = semtypes.listIterator();
    while (semtypeIterator.hasNext()) {
      String semtype = (String)semtypeIterator.next();
      sb.append( semtype + ":" + resultMap.get(semtype) + " ");
      i++;
    }
    logger.debug( sb.toString() );
  }

  // end debug

  /**
   * get term vector for term
   * @param term        term to be looked up.
   * @return pointer to termVector if found, null otherwise
   */
  public int[] getTermVector(String term)
  {
    int termVector[] = null;
    try
      {
        if ((termVector = fIndexSemTypeIndexingTable.get(term)) != null )
	  return termVector;
        else
          return null;
      }
    catch (Exception e)
      {
	logger.error(e.getMessage(), e);
	return null;
      }
  }

  /**
   * get term vector for term
   * <p>
   * this version avoids allocation of term vector by requiring caller to supply 
   * pre-allocated term vector of STVECTORSIZE.
   * </p>
   * @param term        term to be looked up.
   * @param termVector  vector to be filled with contents of
   *                    term vector.
   * @return pointer to termVector if found, null otherwise
   */
  public int[] getTermVector(String term, int termVector[])
  {
    try
      {
        if (fIndexSemTypeIndexingTable.get(term, termVector) != null )
	  return termVector;
        else
          return null;
      }
    catch (RuntimeException e)
      {
        logger.error("RuntimeException in getTermVector: term: " + term + ", message: " + e.getMessage(), e);
	return null;
      }
    catch (Exception e)
      {
	logger.error(e.getMessage(), e);
	return null;
      }
  }


  /**
   * Calculate Semantic Type Indexing Vector for supplied tokenized
   * term list.
   *
   * @param tokens list of tokenized terms to be profiled.
   * @return array of ints representing profile vector
   */
  public int[] calculateStiProfileVector(List tokens)
  {
    int resultVector[] = new int[STVECTORSIZE];
    int sumVector[]    = new int[STVECTORSIZE];
    int termVector[]   = new int[STVECTORSIZE];
    ListIterator st = tokens.listIterator();
    int count = 0;
    while (st.hasNext()) {
      String term = (String)st.next();
      if (isRestrictWord(term) && notStopWord(term)) {
        if (this.getTermVector(term.toUpperCase(), termVector) != null) {
          count++;
          for (int i = 0; i<STVECTORSIZE; i++) {    
            sumVector[i] = sumVector[i] + termVector[i];
          }
        }
      }
    }
    if (count != 0) {
      for (int i = 0; i<STVECTORSIZE; i++) {    
        resultVector[i] = sumVector[i]/count;
      }
    }
    return resultVector;
  }

  /**
   * Calculate Semantic Type Indexing Vector for supplied phrase
   *
   * @param phrase phrase to be profiled.
   * @return array of ints representing profile vector
   */
  public int[] calculateStiProfileVector(String phrase)
  {
    StringBuffer sb = new StringBuffer();
    int resultVector[] = new int[STVECTORSIZE];
    int sumVector[]    = new int[STVECTORSIZE];
    int termVector[]   = new int[STVECTORSIZE];
    StringTokenizer st = new StringTokenizer(phrase, this.PUNCTUATION + this.WHITESPACE);
    int count = 0;
    while (st.hasMoreTokens()) {
      String term = st.nextToken();
      if (isRestrictWord(term.toUpperCase()) && notStopWord(term.toUpperCase())) {
        if (this.getTermVector(term.toUpperCase(), termVector) != null) {
	  // System.out.print("\"" + term.toUpperCase() + "\"");
	  //System.out.println(" -> " + termVector);
          count++;
          for (int i = 0; i<STVECTORSIZE; i++) {    
            sumVector[i] = sumVector[i] + termVector[i];
          }
	} 
      } 
    }
    if (count != 0) {
      for (int i = 0; i<STVECTORSIZE; i++) {    
        resultVector[i] = sumVector[i]/count;
      }
    }
    return resultVector;
  }

  /**
   * Generate a sorted map of result by score (key) -> semantic type (value).
   * 
   * @param resultVector 
   * @return sorted map of result vector
   */
  public SortedMap mapStiResult(int[] resultVector)
  {
    // the supplied anonymous comparator sorts the result by score in reverse order.
    SortedMap resultMap = new TreeMap(new Comparator() {
	public int compare(Object o1, Object o2) {
	  int cc = ((Integer)o1).compareTo((Integer)o2);
	  return (cc < 0 ? 1 : cc > 0 ? -1 : 0);
	}
      });
    // load scores into Sorted Map with associated semantic type name.
    for (int i = 0; i<STVECTORSIZE; i++) {
      resultMap.put(new Integer(resultVector[i]), this.stAbbrev[i]);
    }
    return resultMap;
  }

  /**
   * Generate a sorted map of result by semantic type (key) -> score (value).
   * 
   * @param resultVector 
   * @return sorted map of result vector
   */
  public SortedMap mapStiResultBySemType(int[] resultVector)
  {
    // the supplied anonymous comparator sorts the result by score in reverse order.
    SortedMap resultMap = new TreeMap(new Comparator() {
	public int compare(Object o1, Object o2) {
	  int cc = ((String)o1).compareTo((String)o2);
	  return (cc < 0 ? 1 : cc > 0 ? -1 : 0);
	}
      });
    // load scores into Sorted Map with associated semantic type name.
    for (int i = 0; i<STVECTORSIZE; i++) {
      resultMap.put(this.stAbbrev[i], new Integer(resultVector[i]));
    }
    return resultMap;
  }

  public void displayStiResult(int[] resultVector, int topN)
  {
    SortedMap resultMap = mapStiResult(resultVector);
    int i = 0;
    Iterator mapIterator = resultMap.keySet().iterator();
    while (mapIterator.hasNext() && i < topN) {
      Integer score = (Integer)mapIterator.next();
      System.out.println(resultMap.get(score) + "|" +
			 scoreFormat.format(score.doubleValue()*0.0001));
      i++;
    }
  }

  public String pickBestSemType(int[] result, List semTypeList) 
  {
    int topScore = 0;
    String topSemType = null;

    for (int i = 0; i<result.length; i++) {
      if (result[i] > topScore) {
        topScore = result[i];
        topSemType = this.stAbbrev[i];
      }
    }
    return topSemType;
  }

  public final static void main(String[] args)
  {
    if (args.length > 0) {
      File file = new File(args[0]);
      if (file.exists()) {
	StringBuffer context = new StringBuffer();
	try {
	  BufferedReader br = new BufferedReader(new FileReader(file));
	  String line;
	  while ((line = br.readLine()) != null) {
	    context.append(line).append(" ");
	  }
	  br.close();
	  // System.out.println("context: " + context);
	  SemTypeIndexingMethod stim = new SemTypeIndexingMethod();
	  int[] resultVector = stim.calculateStiProfileVector(context.toString());
	  stim.displayStiResult(resultVector, 10);
	} catch (FileNotFoundException fnfe) {
	  System.err.print(fnfe.getMessage());
	  throw new RuntimeException("method settings cannot be loaded.");
	} catch (IOException ioe) {
	  System.err.print(ioe.getMessage());
	  throw new RuntimeException("method settings cannot be loaded.");
	}	
      } else {
	System.err.println("file does not exist!!");
	System.err.println("usage: java wsd.util.SemanticIndexMethod filename");
      }
    } else {
      System.err.println("usage: java wsd.util.SemanticIndexMethod filename");
      System.exit(1);
    }
  }
}


